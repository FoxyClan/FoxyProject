// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";

/**
* @title FoxyClan contract
* @dev Extends ERC721 Non-Fungible Token Standard basic implementation
*/
contract FoxyClan is ERC721, ERC721Enumerable, Ownable {
    event Merge(address indexed owner, uint256 indexed tokenIdBurned1, uint256 indexed tokenIdBurned2, uint256 newTokenId);

    struct FoxyPointsSpend {
        uint256 tokenId;
        uint256 amount;
    }

    event FoxyPointsSpent(FoxyPointsSpend[] spentPoints, string usage);

    event FoxyPointsTransferred(uint256 indexed fromTokenId, uint256 indexed toTokenId, uint256 amount);

    event ClanDisbanded(uint256 indexed clanId);

    event ClanLeadershipTransferred(uint256 indexed clanId, uint256 oldLeaderTokenId, uint256 newLeaderTokenId);

    event SoulphraseSet(uint256 indexed tokenId, string phrase);

    bool public publicSaleIsActive = false;

    bool public privateSaleIsActive = false;

    string private _BaseURI;

    bool public allowListisActive = false;

    uint256 public constant MAX_SUPPLY = 20000;

    uint256 private _tokenIdOffset = 0; // Offset used to skip token IDs after burns (prevents ID reuse)

    uint256 public burnedToken = 0; // Total number of tokens permanently removed from MAX_SUPPLY

    uint256 public constant maxPublicFoxyMint = 20;

    uint256 public constant publicFoxyPrice = 0.0125 ether;

    uint256 public constant privateFoxyPrice = 0.0075 ether;

    uint256 public saleMintLimit = 0;

    uint256 public currentSaleMinted = 0;

    mapping(address => uint8) private _AllowList;

    mapping(uint256 => uint256) private _pointsTimestamp;

    mapping(uint256 => uint256) private _foxyPoints;

    mapping (uint256 => uint256) public level;

    mapping(uint256 => string) private _soulphrases;

    struct Clan {
        string name;
        uint256 leaderTokenId;
        uint256[] members;
        bool exists;
        string description;
        uint256 maxMembers;
        uint256 minLevel;
    }
    mapping(uint256 => Clan) public clans;
    mapping(uint256 => uint256) public tokenClan;
    uint256 private _clanIdCounter = 1;


    constructor() ERC721("FoxyClan", "FOXY") Ownable(msg.sender) {}


    /**
    * @dev Internal helper to check if a given number of tokens can be minted
    * without exceeding the adjusted MAX_SUPPLY (taking burned tokens into account).
    * Used in all minting-related functions to enforce supply limits.
    * @param amount The number of tokens intended to be minted.
    * @return A boolean indicating whether the minting is allowed.
    */
    function _canMint(uint256 amount) internal view returns (bool) {
        return totalSupply() + amount <= MAX_SUPPLY - burnedToken;
    }


    /**
    * @dev Returns the number of tokens still available for minting,
    * accounting for both total supply and burned tokens.
    * @return The number of NFTs that can still be minted before reaching the supply cap.
    */
    function availableSupply() public view returns (uint256) {
        return MAX_SUPPLY - burnedToken - totalSupply();
    }


    /**
    * @dev Airdrops one NFT per address in the provided list.
    * Each token is initialized with level 1 and 0 Foxy Points.
    * Only callable by the contract owner.
    */
    function airdrop(address[] calldata addresses) external onlyOwner {
        require(_canMint(addresses.length), "Max supply exceeded");
        for (uint256 i = 0; i < addresses.length; i++) {
            uint tokenId = totalSupply() + _tokenIdOffset;
            tokenInitialization(tokenId, 0);
            _safeMint(addresses[i], tokenId);
        }
    }


    /**
    * @dev Returns the current Foxy Points for a specific token.
    * Foxy Points accumulate daily based on the token's level:
    * - Level 1: no passive gain
    * - Level 2: +1 point/day
    * - Level 3: +2 points/day
    * @param tokenId The ID of the token to query.
    * @return The total Foxy Points available for the token.
    */
    function getTokenPoints(uint256 tokenId) public view returns (uint256) {
        _requireOwned(tokenId);
        
        uint256 levelValue = level[tokenId];
        uint256 dailyGain = 0;

        if (levelValue == 2) {
            dailyGain = 1;
        } else if (levelValue == 3) {
            dailyGain = 2;
        }

        uint256 accumulatedPoints = ((block.timestamp - _pointsTimestamp[tokenId]) / 1 days) * dailyGain;
        return _foxyPoints[tokenId] + accumulatedPoints;
    }


    /**
    * @dev Returns the total Foxy Points across all tokens owned by an address.
    * @param owner The address to check.
    * @return The sum of all Foxy Points held by the owner's tokens.
    */
    function getUserPoints(address owner) public view returns (uint256) {
        uint256 balance = balanceOf(owner);
        uint256 totalPoints = 0;

        for (uint256 i = 0; i < balance; i++) {
            uint256 tokenId = tokenOfOwnerByIndex(owner, i);
            totalPoints += getTokenPoints(tokenId);
        }
        return totalPoints;
    }


    /**
    * @dev Spends a specific amount of Foxy Points from a single token.
    * Emits a `FoxyPointsSpent` event containing one entry (the token ID and points spent) and a usage description.
    * Only the token's owner can call this function.
    * @param tokenId The token from which to deduct Foxy Points.
    * @param amount The number of points to deduct.
    * @param usage A string describing the purpose of the point deduction.
    */
    function spendFoxyPoints(uint256 tokenId, uint256 amount, string memory usage) public {
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        require(getTokenPoints(tokenId) >= amount, "Not enough points");

        uint256 updatedPoints = getTokenPoints(tokenId);
        _foxyPoints[tokenId] = updatedPoints - amount;
        _pointsTimestamp[tokenId] = block.timestamp;

        FoxyPointsSpend[] memory spent = new FoxyPointsSpend[](1);
        spent[0] = FoxyPointsSpend(tokenId, amount);

        emit FoxyPointsSpent(spent, usage);
    }


    /**
    * @dev Spends Foxy Points from all tokens owned by the caller.
    * Distributes the deduction across multiple tokens if needed.
    * Emits a `FoxyPointsSpent` event per deduction.
    * Reverts if total available points are insufficient.
    * @param amount The total number of points to spend.
    * @param usage The reason for spending the points.
    */
    function spendFoxyPointsFromCollection(uint256 amount, string memory usage) public {
        uint256 balance = balanceOf(msg.sender);
        require(balance > 0, "You don't own any Foxy tokens");

        uint256 totalAvailable = getUserPoints(msg.sender);
        require(totalAvailable >= amount, "Not enough total points");

        uint256 remaining = amount;
        FoxyPointsSpend[] memory spent = new FoxyPointsSpend[](balance);
        uint256 index = 0;

        for (uint256 i = 0; i < balance && remaining > 0; i++) {
            uint256 tokenId = tokenOfOwnerByIndex(msg.sender, i);
            uint256 available = getTokenPoints(tokenId);

            if (available == 0) continue;

            uint256 toSpend = available >= remaining ? remaining : available;
            _foxyPoints[tokenId] = available - toSpend;
            _pointsTimestamp[tokenId] = block.timestamp;

            spent[index] = FoxyPointsSpend(tokenId, toSpend);
            index++;

            remaining -= toSpend;
        }

        require(remaining == 0, "Internal error: Not enough points deducted");

        FoxyPointsSpend[] memory finalSpent = new FoxyPointsSpend[](index);
        for (uint256 j = 0; j < index; j++) {
            finalSpent[j] = spent[j];
        }

        emit FoxyPointsSpent(finalSpent, usage);
    }


    /**
    * @dev Transfers Foxy Points from one token to another.
    * Tokens must be different, and the caller must own the sender token.
    * Emits a `FoxyPointsTransferred` event.
    * @param fromTokenId The token sending the points.
    * @param toTokenId The recipient token.
    * @param amount The number of points to transfer.
    */
    function sendFoxyPointsFromToken(uint256 fromTokenId, uint256 toTokenId, uint256 amount) external {
        require(ownerOf(fromTokenId) == msg.sender, "You must own the sender token");
        require(fromTokenId != toTokenId, "Cannot send to the same token");
        _requireOwned(toTokenId);

        uint256 senderPoints = getTokenPoints(fromTokenId);
        require(senderPoints >= amount, "Not enough FoxyPoints to transfer");

        _foxyPoints[fromTokenId] = senderPoints - amount;
        _pointsTimestamp[fromTokenId] = block.timestamp;

        _foxyPoints[toTokenId] += amount;
        _pointsTimestamp[toTokenId] = block.timestamp;

        emit FoxyPointsTransferred(fromTokenId, toTokenId, amount);
    }


    /**
    * @dev Rewards specific tokens with Foxy Points after winning challenges, completing missions, 
    * or participating games or events.
    * This function allows the contract owner to add a fixed number of points to each selected token.
    */
    function addFoxyPointsToTokens(uint256[] calldata tokenIds, uint256 pointsToAdd) external onlyOwner {
        require(tokenIds.length > 0, "Token list cannot be empty");
        
        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            _requireOwned(tokenId);
            _foxyPoints[tokenId] += pointsToAdd;
        }
    }


    function setBaseURI(string memory uri) external onlyOwner() {
        _BaseURI = uri;
    }


    function _baseURI() internal view override returns (string memory) {
        return _BaseURI;
    }


    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        _requireOwned(tokenId);

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, Strings.toString(tokenId), ".json")) : "";
    }


    function flipPublicSaleState(uint256 maxMintAmount, bool state) external onlyOwner {
        publicSaleIsActive = state;
        if (publicSaleIsActive) {
            saleMintLimit = maxMintAmount;
            currentSaleMinted = 0;
        } else {
            saleMintLimit = 0;
        }
    }


    function flipPrivateSaleState() external onlyOwner {
        privateSaleIsActive = !privateSaleIsActive;
    }


    function flipAllowListState() external onlyOwner {
        allowListisActive = !allowListisActive;
    }


    /**
    * @dev Sets the allow list for addresses and their corresponding mint limits.
    * @param addresses An array of addresses that will be allowed to mint FoxyClan nfts.
    * @param numAllowedToMint The number of tokens allowed to be minted for each address.
    */
    function setAllowList(address[] calldata addresses, uint8 numAllowedToMint) external onlyOwner {
        for (uint256 i = 0; i < addresses.length; i++) {
            _AllowList[addresses[i]] = numAllowedToMint;
        }
    }


    /*
    * @dev Returns the number of tokens available to mint for a specific address.
    * @param addr The address to check.
    * @return The number of tokens available to mint for a specific address.
    */
    function numAvailableToMint(address addr) external view returns (uint8) {
        return _AllowList[addr];
    }


    /**
    * @dev Mints a specified number of tokens for a user on the allowlist.
    * This function is used during allowlist sales (either public or private).
    * Each minted token is initialized with level 1 and 50 Foxy Points.
    */
    function mintAllowList(uint8 numberOfTokens) external payable {
        uint256 costToMint;
        if (privateSaleIsActive) {
            costToMint = privateFoxyPrice * numberOfTokens;
        } else {
            costToMint = publicFoxyPrice * numberOfTokens;
        }
        require(allowListisActive, "Allow list is not active");
        require(numberOfTokens <= _AllowList[msg.sender], "Exceeded max available to purchase");
        require(_canMint(numberOfTokens), "Purchase would exceed max tokens");
        require(costToMint <= msg.value, "Ether value sent is not correct");

        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = totalSupply() + _tokenIdOffset;
            _AllowList[msg.sender] --;
            tokenInitialization(tokenId, 50);
            _safeMint(msg.sender, tokenId);
        }
    }


    /**
    * @dev Mints tokens during the public sale phase.
    * Each minted token is initialized with level 1 and 50 Foxy Points.
    */
    function mint(uint256 numberOfTokens) public payable {
        uint256 costToMint = publicFoxyPrice * numberOfTokens;
        
        require(publicSaleIsActive, "Sale must be active to mint Foxy");
        require(numberOfTokens <= maxPublicFoxyMint, "Can only mint a limited number of tokens at a time");
        require(_canMint(numberOfTokens), "Purchase would exceed max tokens");
        require(costToMint <= msg.value, "Ether value sent is not correct");

        if (saleMintLimit > 0) {
            require(currentSaleMinted + numberOfTokens <= saleMintLimit, "Minting limit for this sale reached");
        }

        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = totalSupply() + _tokenIdOffset;
            tokenInitialization(tokenId, 50);
            _safeMint(msg.sender, tokenId);
        }
        currentSaleMinted += numberOfTokens;
    }


    /**
    * @dev Merges two owned tokens into a new one with upgraded level and combined FoxyPoints.
    * 
    * Requirements:
    * - Caller must own both tokens.
    * - Tokens must be different.
    * - At least one of the tokens must be level 1.
    * - Both tokens must be level strictly lower than 3.
    * 
    * Behavior:
    * - Burns the two source tokens.
    * - Mints a new token with:
    *   - Level increased by 1, based on the highest level among the two.
    *   - FoxyPoints from both tokens combined, plus a merge bonus (100 for level 2, 250 for level 3).
    *   - A fresh timestamp for point accumulation tracking.
    * - Increments `_tokenIdOffset` by 2 to maintain correct token indexing.
    * - Increments `burnedToken` by 1, since one token is permanently removed from supply.
    * - Emits a `Merge` event with the old and new token IDs.
    */
    function merge(uint256 tokenId1, uint256 tokenId2) external {
        require(ownerOf(tokenId1) == msg.sender, "You must own tokenId1");
        require(ownerOf(tokenId2) == msg.sender, "You must own tokenId2");
        require(tokenId1 != tokenId2, "Cannot merge the same token");
        require(level[tokenId1] == 1 || level[tokenId2] == 1, "At least one of the two tokens must be level 1");
        require(level[tokenId1] < 3 && level[tokenId2] < 3, "A level 3 token cannot be merged");

        uint256 tokenPoints1 = getTokenPoints(tokenId1);
        uint256 tokenPoints2 = getTokenPoints(tokenId2);

        uint256 newLevel = level[tokenId1] > level[tokenId2] 
            ? level[tokenId1] 
            : level[tokenId2];
        newLevel++;

        _burn(tokenId1);
        _burn(tokenId2);
        _tokenIdOffset += 2;
        burnedToken += 1;

        uint256 tokenId = totalSupply() + _tokenIdOffset;
        level[tokenId] = newLevel;

        uint256 mergePoints = level[tokenId] == 2 ? 100 : 250;
        _foxyPoints[tokenId] = tokenPoints1 + tokenPoints2 + mergePoints;
        _pointsTimestamp[tokenId] = block.timestamp;
        level[tokenId] = newLevel;

        emit Merge(msg.sender, tokenId1, tokenId2, tokenId);
        _safeMint(msg.sender, tokenId);
    }

    
    /**
    * @dev Initializes a newly minted token with default values.
    * Sets the level to 1, assigns the initial amount of Foxy Points,
    * and records the current timestamp to start point accumulation tracking.
    */
    function tokenInitialization(uint256 tokenId, uint256 initialPoints) internal {
        level[tokenId] = 1;
        _foxyPoints[tokenId] = initialPoints;
        _pointsTimestamp[tokenId] = block.timestamp;
    }


    /**
    * @dev Allows the owner of a level 2+ token to set a soulphrase.
    *      This feature is only available once at least 30 tokens have been burned.
    * @param tokenId The token to assign the phrase to.
    * @param phrase The phrase to be stored in the token.
    */
    function setSoulphrase(uint256 tokenId, string calldata phrase) external {
        require(ownerOf(tokenId) == msg.sender, "You must own this token");
        require(level[tokenId] >= 2, "Only level 2+ tokens can set a soulphrase");
        require(burnedToken >= 30, "Soulphrase is locked until 30 tokens are burned");
        require(bytes(phrase).length <= 100, "Phrase too long (max 100 characters)");
        
        _soulphrases[tokenId] = phrase;
        emit SoulphraseSet(tokenId, phrase);
    }


    function getSoulphrase(uint256 tokenId) public view returns (string memory) {
        _requireOwned(tokenId);
        return _soulphrases[tokenId];
    }


    /**
    * @dev Creates a new clan. Only a level 3 token can be used to create one.
    *      This feature is only available once at least 100 tokens have been burned.
    *      Requires 30 Foxy Points from the token used.
    * @param tokenId The token used to create the clan (must be level 3).
    * @param name The name of the clan.
    */
    function createClan(
        uint256 tokenId,
        string calldata name,
        string calldata description,
        uint256 minLevel,
        uint256 maxMembers
    ) external {
        require(burnedToken >= 100, "Clans are locked until 100 tokens are burned");
        require(ownerOf(tokenId) == msg.sender, "You must own the token");
        require(level[tokenId] == 3, "Only level 3 tokens can create clans");
        require(tokenClan[tokenId] == 0, "Token already in a clan");
        require(minLevel >= 1 && minLevel <= 3, "Invalid min level");
        require(bytes(name).length > 0 && bytes(name).length <= 32, "Clan name must be 1-32 characters");
        require(bytes(description).length <= 256, "Description too long (max 256)");
        require(maxMembers >= 1 && maxMembers <= 100, "Invalid member limit");

        spendFoxyPoints(tokenId, 30, "Clan creation");

        uint256 clanId = _clanIdCounter++;
        clans[clanId] = Clan({
            name: name,
            description: description,
            leaderTokenId: tokenId,
            members: new uint256 [](0),
            exists: true,
            minLevel: minLevel,
            maxMembers: maxMembers
        });

        clans[clanId].members.push(tokenId);
        tokenClan[tokenId] = clanId;
    }


    function updateClanSettings(
        uint256 clanId,
        string calldata name,
        string calldata description,
        uint256 minLevel,
        uint256 maxMembers
    ) external {
        require(clans[clanId].exists, "Clan does not exist");
        uint256 leaderToken = clans[clanId].leaderTokenId;
        require(ownerOf(leaderToken) == msg.sender, "Only the clan leader can update settings");
        
        if (bytes(name).length > 0) {
            require(bytes(name).length <= 32, "Clan name must be 1-32 characters");
            clans[clanId].name = name;
        }

        if (bytes(description).length > 0) {
            require(bytes(description).length <= 256, "Description too long (max 256)");
            clans[clanId].description = description;
        }

        if (minLevel != 0) {
            require(minLevel >= 1 && minLevel <= 3, "Invalid min level");
            clans[clanId].minLevel = minLevel;
        }

        if (maxMembers != 0) {
            require(maxMembers >= clans[clanId].members.length, "Cannot set maxMembers below current count");
            require(maxMembers <= 100, "Max members limit exceeded");
            clans[clanId].maxMembers = maxMembers;
        }
    }


    function joinClan(uint256 tokenId, uint256 clanId) external {
        require(ownerOf(tokenId) == msg.sender, "You must own the token");
        require(clans[clanId].exists, "Clan does not exist");
        require(tokenClan[tokenId] == 0, "Token already in a clan");
        require(level[tokenId] >= clans[clanId].minLevel, "Token level too low for this clan");
        require(clans[clanId].members.length < clans[clanId].maxMembers, "Clan is full");

        clans[clanId].members.push(tokenId);
        tokenClan[tokenId] = clanId;
    }


    function leaveClan(uint256 tokenId) external {
        require(ownerOf(tokenId) == msg.sender, "You must own the token");
        uint256 clanId = tokenClan[tokenId];
        require(clanId != 0, "Token is not in a clan");

        Clan storage clan = clans[clanId];

        for (uint256 i = 0; i < clan.members.length; i++) {
            if (clan.members[i] == tokenId) {
                clan.members[i] = clan.members[clan.members.length - 1];
                clan.members.pop();
                break;
            }
        }
        tokenClan[tokenId] = 0;

        if (clan.leaderTokenId == tokenId) {
            for (uint256 i = 0; i < clan.members.length; i++) {
                tokenClan[clan.members[i]] = 0;
            }
            delete clans[clanId];
            emit ClanDisbanded(clanId);
        }
    }
    

    /**
    * @dev Transfers leadership of a clan to another member.
    * 
    * Requirements:
    * - The clan must exist.
    * - The caller must be the current leader of the clan.
    * - The new leader token must belong to the same clan.
    * - The new leader token must be of level 3.
    *
    * Emits a `ClanLeadershipTransferred` event.
    *
    * @param clanId The ID of the clan whose leadership is being transferred.
    * @param newLeaderTokenId The token ID of the member who will become the new leader.
    */
    function transferClanLeadership(uint256 clanId, uint256 newLeaderTokenId) external {
        require(clans[clanId].exists, "Clan does not exist");
        uint256 currentLeaderTokenId = clans[clanId].leaderTokenId;
        require(ownerOf(currentLeaderTokenId) == msg.sender, "Only the clan leader can transfer leadership");
        require(tokenClan[newLeaderTokenId] == clanId, "New leader must be a clan member");
        require(level[newLeaderTokenId] == 3, "New leader must be level 3");

        clans[clanId].leaderTokenId = newLeaderTokenId;
        emit ClanLeadershipTransferred(clanId, currentLeaderTokenId, newLeaderTokenId);
    }


    function getClanMembers(uint256 clanId) public view returns (uint256[] memory) {
        require(clans[clanId].exists, "Clan does not exist");
        return clans[clanId].members;
    }


    function getClanOfToken(uint256 tokenId) public view returns (uint256) {
        return tokenClan[tokenId];
    }


    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }


    function _update(address to, uint256 tokenId, address auth) internal override(ERC721, ERC721Enumerable) returns (address) {
        return super._update(to, tokenId, auth);
    }


    function _increaseBalance(address account, uint128 amount) internal override(ERC721, ERC721Enumerable) {
        return super._increaseBalance(account, amount);
    }


    /**
    * @dev Reserves a specified number of tokens for the contract owner.
    * This function allow the creator to keep a certain number of tokens 
    * for future uses, such as giveaways, collaborations or special events.
    */
    function reserveFoxy(uint256 n) public onlyOwner {
        require(_canMint(n), "Purchase would exceed max tokens");
        for (uint256 i = 0; i < n; i++) {
            uint256 tokenId = totalSupply() + _tokenIdOffset;
            tokenInitialization(tokenId, 50);
            _safeMint(msg.sender, tokenId);
        }
    }


    function withdraw() public onlyOwner {
        uint balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    }

}